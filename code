Slot_v8.0_최종.txt
module Slot(CLK, RESET, KEY_COL, KEY_ROW, SEG_C, SEG_SEL, LED_DATA, BUZZER_OUT);
	input CLK, RESET;
	output [2:0] KEY_COL;
	input [3:0] KEY_ROW;
	output [6:0] SEG_C;
	output [7:0] SEG_SEL;
	output [15:0] LED_DATA;
	output BUZZER_OUT;

	reg [1:0] STATE; // 몇 번 눌렀나 ?
	wire [3:0] VALUE[2:0]; // segment용
	reg [3:0] VAL[2:0]; // 저장
	reg [1:0] WIN; // 숫자 비교 결과
	wire POP;
	reg STATE0, STATE1, STATE2;

	KEYPAD (CLK, RESET, KEY_COL, KEY_ROW, POP);
	SEVEN_SEG SEG(CLK, RESET, STATE, SEG_C, SEG_SEL, VALUE[0], VALUE[1], VALUE[2]);
	BUZZER (CLK, RESET, WIN, BUZZER_OUT);
	USER_LED(CLK, RESET, WIN, LED_DATA);

	initial
	begin
		VAL[0] <= 0;
		VAL[1] <= 0;
		VAL[2] <= 0;
		WIN <= 0;
		STATE <= 0;
	end
	
	always @(posedge POP) 
	begin
		if(RESET)
		begin
			STATE = 0;
			VAL[0] <= 0;
			VAL[1] <= 0;
			VAL[2] <= 0;
		end
			
		else
		begin
		/************** KEY CALL **************/
			if(POP == 1)
			begin 
				if(STATE == 2'b11)
				begin
					STATE = 0;
				end
				else STATE = (STATE+1);
			end
			
				
		/**************** Value store ***************/
		
			case(STATE)
				2'b01: VAL[0] <= VALUE[0];
						
				2'b10: VAL[1] <= VALUE[1];
						
				2'b11: VAL[2] <= VALUE[2];			
			endcase
		end
	end
	
	always @(STATE)
			/*************** if WIN or NOT ****************/
			if(STATE == 2'b11)
			begin
				if(VAL[0] == VAL[1] && VAL[1] == VAL[2])
				begin
					if(VAL[2] == 4'b0111)
					begin WIN = 2; end
					else 
					begin WIN = 1;end
				end
	
				else
				begin
					WIN = 0;
				end
			end
			
			else WIN = 0;


endmodule







/************************** 7 SEGMENT ****************************/
module SEVEN_SEG(CLK, RESET, STATE, SEG_C, SEG_SEL, VAL1, VAL2, VAL3);
	input CLK, RESET;
	input [1:0] STATE; // STOP SEG SELECT
	output [6:0] SEG_C; 
	output [7:0] SEG_SEL;
	output [3:0] VAL1; // EACH SEGMENT VALUE
	output [3:0] VAL2;
	output [3:0] VAL3;
	
	reg [6:0] SEG_C;
	reg [3:0] COUNT_1, COUNT_10, COUNT_100, COUNT_TMP;
	reg [21:0] CLK_COUNT;
	reg [63:0] CLK_COUNT1;
	reg [1:0] SEL_SEG;
	reg [3:0] VAL1;
	reg [3:0] VAL2;
	reg [3:0] VAL3;

	reg [7:0] SEG_SEL;
	reg CLK1, CLK2;
	
	/************ CLOCK ***************/
	always @(negedge CLK or posedge RESET) // CLK/10 25M => 1k : 25000
		if(RESET) CLK1<=0; 
		else if (CLK_COUNT==12499) 
		begin
			CLK_COUNT<=0; CLK1<=1;
		end	 
		else 
		begin 
			CLK_COUNT <= CLK_COUNT+1; CLK1<=0; 
		end 
	
	always @(negedge CLK or posedge RESET) // CLK/10 25M => 20 : 2500000
		if(RESET) CLK2<=0; 
		else if (CLK_COUNT1==2500000) 
		begin 
			CLK_COUNT1<=0; CLK2<=1;
		end 
		else
		begin
			CLK_COUNT1 <= CLK_COUNT1+1;
			CLK2<=0; 
		end 
 	
	/************* CHANGING the SEG VALUE ***************/
	initial 
	begin
		VAL1 <= 0;
		VAL2 <= 0;
		VAL3 <= 0;
	end
	
	always @(negedge CLK2 or posedge RESET)
	begin
			
		if(RESET)
			begin
				COUNT_1<=VAL3;
				COUNT_10<=VAL2;
				COUNT_100<=VAL1;
			end
			
		else
			case(STATE)
			2'b00 :		// ALL OP
				begin
				if (COUNT_1==9) COUNT_1<=0;
				else COUNT_1<=COUNT_1+1;
				if (COUNT_10==9) COUNT_10<=0;
				else COUNT_10<=COUNT_10+1;
				if (COUNT_100==9) COUNT_100<=0;
				else COUNT_100<=COUNT_100+1;
				end
					
			2'b01 : 	// COUNT_1 STOP
				begin
				if (COUNT_1==9)  COUNT_1<=0;
				else COUNT_1<=COUNT_1+1;
				if (COUNT_10==9) COUNT_10<=0;
				else COUNT_10<=COUNT_10+1;
				
				COUNT_100 <= VAL1;
				end
					
			2'b10 : 	// COUNT_1, COUNT_10 STOP
				begin
				if (COUNT_1==9) COUNT_1<=0;
				else COUNT_1 <= COUNT_1+1;	
				
				COUNT_100 <= VAL1;
				COUNT_10 <= VAL2;
				end
				
			2'b11 : 	// COUNT_1, COUNT_10, COUNT_100 STOP
				begin
					COUNT_1 <= VAL3;
					COUNT_10 <= VAL2;
					COUNT_100 <= VAL1;	
				end
			endcase	
			
		VAL3 <= COUNT_1;
		VAL2 <= COUNT_10;
		VAL1 <= COUNT_100;		
					 
	end
		
		
	

	/********** dont tocuh **************/

 	always@(negedge CLK1) // SEC_SEG
 		if(SEL_SEG==2) SEL_SEG <=0;
 		else SEL_SEG <= SEL_SEG+1;

	always@(COUNT_1 or COUNT_10 or COUNT_100 or SEL_SEG)
	case (SEL_SEG) 
		0 : COUNT_TMP <= COUNT_1;
	 	1 : COUNT_TMP <= COUNT_10;
		2 : COUNT_TMP <= COUNT_100;
	endcase
	 
 	always@(SEL_SEG)
 	case(SEL_SEG)
		0 : SEG_SEL <= 8'b1111_1110;
		1 : SEG_SEL <= 8'b1111_1101;
		2 : SEG_SEL <= 8'b1111_1011;
	endcase

	SEG_DEC U0 (COUNT_TMP, SEG_C); 
endmodule



module SEG_DEC(DIGIT, SEG_DEC);
	input [3:0] DIGIT;
	output [6:0] SEG_DEC;
	reg [6:0] SEG_DEC;
	always @(DIGIT)
	case (DIGIT) // gfe_dcba 
		0 : SEG_DEC <= 7'h3f; // 011_1111
		1 : SEG_DEC <= 7'h06; // 000_0110
		2 : SEG_DEC <= 7'h5b; // 101_1011
		3 : SEG_DEC <= 7'h4f; // 100_1111
		4 : SEG_DEC <= 7'h66; // 010_0110
		5 : SEG_DEC <= 7'h6d; // 110_1101
		6 : SEG_DEC <= 7'h7c; // 111_1100
		7 : SEG_DEC <= 7'h07; // 000_0111
		8 : SEG_DEC <= 7'h7f; // 111_1111
 		9 : SEG_DEC <= 7'h67; // 110_0111 
	endcase
endmodule




/************************** USER LED ****************************/
module USER_LED(CLK, RESET, WIN, led_data);

	input CLK;
	input RESET;
	input [1:0] WIN;
	output [15:0] led_data;

	reg [15:0]  led_data;
	integer cnt;
	reg CLK2;
	reg [21:0] CLK_COUNT1;


	always @(negedge CLK or posedge RESET) // CLK/10 25M => 20 : 2500000
		if(RESET) CLK2<=0; 
		else if (CLK_COUNT1==1249999) 
		begin 
			CLK_COUNT1<=0; CLK2<=1;
		end 
		else
		begin
			CLK_COUNT1 <= CLK_COUNT1+1;
			CLK2<=0; 
		end
		
		

	always @(posedge CLK2) 
	begin
		if (WIN == 0) begin led_data <= 16'b0000_0000_0000_0000; end		// 불 꺼짐
	
		else if (WIN == 1) begin led_data <= 16'b0000_1111_0000_1111; end	// 불 켜짐
		
		else if (WIN == 2)
		begin
			cnt = 0;
			led_data <= 16'b1111_1111_1111_1111;
			#10 for (cnt=0; cnt<128; cnt=cnt+1)
				begin 
				#10 led_data <= ~led_data;
				end
		end
	end
endmodule







/************************** BUZZER ****************************/
module BUZZER (CLOCK, RESET, WIN, piezo_out);
	input CLOCK, RESET;
	input [1:0] WIN;
	output piezo_out;

	piezo_tone U0_piezo_tone(.clk(CLOCK), .rst(RESET), .win(WIN), .piezo_freq(piezo_out));	
	
endmodule


module piezo_tone (clk, rst, win, piezo_freq);
	input	clk, rst;
	input	win;
	output	piezo_freq;

	reg	[9:0]piezo_cnt;
 	reg	piezo_freq;
	reg	[9:0]cnt;

 //key 입력에 따라 주파수 분주기의 계수값 piezo_cnt를 선택
 //1옥타브 상승시 주파수는 2배가 되므로, 분주기 계수값은 1/2이 됨.
	always @(posedge clk)
	begin
		if(win == 0) begin piezo_cnt = 0; end
		else if(win == 1) begin piezo_cnt = 1000;end
		else if(win == 2) begin piezo_cnt = 1500; end
		else begin piezo_cnt = 0; end 
	end

	always @(posedge clk or posedge rst)
	begin
		if (rst)
		begin
 		cnt <= 0;
		piezo_freq <= 0;
 		end
 
		else
		begin
 			if (cnt == piezo_cnt) begin
 			cnt <= 0;
 			piezo_freq <= ~piezo_freq;
 		end
 		else   cnt <= cnt + 1;
 	end

end 
endmodule



/********************** KEYPAD ************************/

module KEYPAD(clk, rst, key_col, key_row, pop);
	input 	clk, rst;
	input	[3:0] 	key_row;
	output	[2:0]	key_col;
	output		pop;
	reg	[11:0]	key_data;
	reg	[2:0]	state;
	
	
	reg pop;
	reg [13:0]  counts;
	reg clk1;
	wire	key_stop;
	// define state of FSM
	parameter no_scan = 3'b000;
	parameter column1 = 3'b001;
	parameter column2 = 3'b010;
	parameter column3 = 3'b100; 
	
	assign key_stop = key_row[0] | key_row[1] | key_row[2] | key_row[3] ;
	assign key_col = state;
	
	always @(posedge clk or posedge rst)  begin
	  	if(rst) begin counts <= 0; clk1 <= 1; end
		else if (counts >= 12499) begin counts <= 0; clk1 <= !clk1; end
		else counts <= counts +1; end
	
	// FSM drive
	always @(posedge clk1 or posedge rst)
	begin
		if (rst) state <= no_scan;
		else begin
		  if (!key_stop) begin
		    case (state)
		    no_scan : state <= column1;
		    column1 : state <= column2;
		    column2 : state <= column3;
		    column3 : state <= column1;
		    default : state <= no_scan;
		    endcase
		  end
		end
	end
	// key_data
	always @ (posedge clk1) begin
	case (state)
	  column1 : case (key_row)
	  	4'b0001 : key_data <= 12'b0000_0000_0001; // key_1
	  	4'b0010 : key_data <= 12'b0000_0000_1000; // key_4 
	  	4'b0100 : key_data <= 12'b0000_0100_0000; // key_7
	  	4'b1000 : key_data <= 12'b0010_0000_0000; // key_*
	  	default : key_data <= 12'b000000000000;
	  	endcase
	  column2 : case (key_row)
	  	4'b0001 : key_data <= 12'b0000_0000_0010; // key_2
	  	4'b0010 : key_data <= 12'b0000_0001_0000; // key_5 
	  	4'b0100 : key_data <= 12'b0000_1000_0000; // key_8
	  	4'b1000 : key_data <= 12'b0100_0000_0000; // key_0
	  	default : key_data <= 12'b000000000000;
	  	endcase
	  column3 : case (key_row)
	  	4'b0001 : key_data <= 12'b0000_0000_0100; // key_3
	  	4'b0010 : key_data <= 12'b0000_0010_0000; // key_6 
	  	4'b0100 : key_data <= 12'b0001_0000_0000; // key_9
	  	4'b1000 : key_data <= 12'b1000_0000_0000; // key_#
	  	default : key_data <= 12'b000000000000;
	  	endcase	  	
	  default : key_data <= 12'b0000_0000_0000;
	endcase
	end


	always @(negedge clk or posedge rst)
	begin
		if (rst)
			pop = 0;
	
		else
		begin
			if (key_data != 12'b0000_0000_0000)
				pop <= 1;
				
			else
				pop <= 0;
				
		end
	end
	

endmodule 
